from ismatching import ismatching # Rust Functions
from numpy.typing import NDArray
import numpy as np
from scipy.sparse import csc_matrix
from numpy import int64, uint8, uint64, float64, uintp
from typing import Dict, List, Optional, Tuple, Union
from pymatching import Matching

def generate_errors(
    num_qubits: Union[int, uint64],
    num_samples: Union[int, uint64] = 1,
    noise_level: Union[float, float64] = 0.5,
    num_threads: Union[int, uintp] = 0,
    error_weight: Optional[Union[int, uint64]] = None,
    rng_seed: Optional[int] = None, ## Up to 32 bytes
) -> NDArray[uint8]:
    """
    Generates qubit errors in the binary symplectic representation. X, Y, and Z
    errors are generated with equal probability.

    Parameters
    ----------
    num_qubits : Union[int, uint64]
        The number of qubits for generation.
    num_samples : Union[int, uint64], optional
        The number of samples to take.
        By default 1
    noise_level : Union[float, float64], optional
        The noise level of the system.
        If error_weight is not None, then this parameter is ignored.
        By default 0.5
    num_threads : Union[int, uintp], optional
        The number of threads to allocate.
        If 0, then the number of threads would be set to the number of logical
        cores for your cpu.
        By default 0
    error_weight : Optional[Union[int, uint64]], optional
        The Hamming Weight of the error generated.
        By default None
    rng_seed : Optional[int], optional
        Seed for RNG. Accept an int upto 32 bytes. It is expected that the bits
        within the seed are well distributed. If this function is being called
        in a loop, it is recommended that the seed be generated by a seeded
        rng such as numpy.random.Generator for each iteration. If None then
        randomness will be given by the operating system.
        By default None

    Returns
    -------
    NDArray[uint8]
        Each row of the array contains a single error sample. The first half
        of each row contains the Z error on each qubit and the second half
        contains the X error.
    """
    
    return ismatching._generate_errors(
        num_qubits,
        num_samples,
        noise_level,
        num_threads,
        error_weight,
        rng_seed,
    )


def generate_errors_from_check(
    parity_check_matrix: NDArray[uint8],
    num_samples: Union[int, uint64] = 1,
    noise_level: Union[float, float64] = 0.5,
    num_threads: Union[int, uintp] = 0,
    error_weight: Optional[Union[int, uint64]] = None,
    rng_seed: Optional[int] = None,
) -> NDArray[uint8]:
    """
    MAY BE REMOVED IN THE FUTURE, USE generate_errors() INSTEAD.

    Generates qubit errors in a binary format. X, Y, and Z errors are generated
    with equal probability.

    Parameters
    ----------
    parity_check_matrix : NDArray[uint8]
        The check matrix used to generate the syndrome for the errors.
    num_samples : Union[int, uint64], optional
        The number of samples to take.
        By default 1
    noise_level : Union[float, float64], optional
        The noise level of the system.
        If error_weight is not None, then this parameter is ignored.
        By default 0.5
    num_threads : Union[int, uintp], optional
        The number of threads to allocate.
        If 0, then the number of threads would be set to the number of logical
        cores for your cpu.
        By default 0
    error_weight : Optional[Union[int, uint64]], optional
        The Hamming Weight of the error generated.
        By default None
    rng_seed : Optional[int], optional
        Seed for RNG. Accept an int upto 32 bytes. It is expected that the bits
        within the seed are well distributed. If this function is being called
        in a loop, it is recommended that the seed be generated by a seeded
        rng such as numpy.random.Generator for each iteration. If None then
        randomness will be given by the operating system.
        By default None

    Returns
    -------
    NDArray[uint8]
        Each row of the array contains a single error sample. The first half
        of each row contains the Z error on each qubit and the second half
        contains the X error.
    """

    num_qubits = parity_check_matrix.shape[1]//2
    return generate_errors(
        num_qubits,
        num_samples,
        noise_level,
        num_threads,
        error_weight,
        rng_seed,
    )


def determine_logical_errors(
    errors: NDArray[uint8],
    predictions: NDArray[uint8],
    num_threads: Union[int, uintp] = 0,
) -> NDArray[uint8]:
    """
    Sums the errors to the predictions generated by a decoder (such as
    PyMatching) and returns whether the error caused a logical error.

    Parameters
    ----------
    errors : NDArray[uint8]
        A 2D array containing errors. Each row should be a single sample of an
        error.
    predictions : NDArray[uint8]
        A 2D array containing error predictions. Each row should contain a
        single error prediction
    num_threads : Union[int, uintp], optional
        The number of threads to allocate.
        If 0, then the number of threads would be set to the number of logical
        cores for your cpu.
        By default 0

    Returns
    -------
    NDArray[uint8]
        A 1D array containing the 1 if a logical error and 0 otherwise for each
        shot.
    """
    return ismatching._determine_logical_errors(errors, predictions, num_threads)


def generate_syndromes(
    parity_check_matrix: Union[NDArray[uint8], csc_matrix],
    errors: NDArray[uint8],
    num_threads: Union[int, uintp]=0,
)-> NDArray[uint8]:
    return (errors @ parity_check_matrix.transpose()) % uint8(2)


def get_stats(data: NDArray[uint8]) -> Tuple[float64, float64]:
    """
    Calculates the mean and standard error of a 1D array of data.

    Parameters
    ----------
    data : NDArray[uint8]

    Returns
    -------
    Tuple[float64, float64]
        A tuple in the format: (mean, standard_error)
    """
    mean = np.average(data)
    stddev = np.std(data, ddof=1)
    n = len(data)
    return (mean, stddev/(np.sqrt(n)))


def monte_carlo(
    parity_check_matrix: Union[NDArray[uint8], csc_matrix],
    noise_level: Union[float, float64],
    num_samples: Union[int, uint64] = 1,
    num_threads: Union[int, uintp] = 0,
    matching: Optional[Matching] = None,
    rng_seed: Optional[int] = None,  ## Up to 32 bytes
) -> Tuple[float64, float64]:
    """
    Generates qubit errors in a binary format. X, Y, and Z errors are generated
    with equal probability.
    Parameters
    ----------
    parity_check_matrix : NDArray[uint8]
        The check matrix used to generate the syndrome for the errors.
    noise_level : Union[float, float64]
        The noise level of the system.
    num_samples : Union[int, uint64], optional
        The number of samples of errors taken at the error rate specified.
        By default 1
    num_threads : Union[int, uintp], optional
        The number of threads to allocate.
        If 0, then the number of threads would be set to the number of logical
        cores for your cpu.
        By default 0
    matching : Optional[Matching], optional
        A Matching object created by PyMatching
        If none, one will be generated from parity_check_matrix.
        By default None
    rng_seed : Optional[int], optional
        Seed for RNG. Accept an int upto 32 bytes. It is expected that the bits
        within the seed are well distributed. If this function is being called
        in a loop, it is recommended that the seed be generated by a seeded
        rng such as numpy.random.Generator for each iteration. If None then
        randomness will be given by the operating system.
        By default None

    Returns
    -------
    Tuple[float64, float64]
        A tuple containing the mean and standard error of the Monte Carlo
        simulation in the format: (mean, standard_error)

    """

    matching = Matching(parity_check_matrix) if matching is None else matching
    
    errors = generate_errors(
        matching.num_nodes,
        num_samples,
        noise_level,
        num_threads,
        rng_seed=rng_seed
    )
    
    syndromes = generate_syndromes(
        parity_check_matrix,
        errors,
        num_threads
    )

    predictions = matching.decode_batch(syndromes)
    # TODO: Reconsider assertion
    assert type(predictions) is np.ndarray

    failures = determine_logical_errors(errors,predictions,num_threads)

    return get_stats(failures)